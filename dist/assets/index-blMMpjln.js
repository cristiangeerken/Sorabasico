var H=Object.defineProperty;var U=t=>{throw TypeError(t)};var V=(t,e,n)=>e in t?H(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var g=(t,e,n)=>V(t,typeof e!="symbol"?e+"":e,n),_=(t,e,n)=>e.has(t)||U("Cannot "+n);var d=(t,e,n)=>(_(t,e,"read from private field"),n?n.call(t):e.get(t)),y=(t,e,n)=>e.has(t)?U("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),O=(t,e,n,o)=>(_(t,e,"write to private field"),o?o.call(t,n):e.set(t,n),n);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))o(a);new MutationObserver(a=>{for(const r of a)if(r.type==="childList")for(const s of r.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&o(s)}).observe(document,{childList:!0,subtree:!0});function n(a){const r={};return a.integrity&&(r.integrity=a.integrity),a.referrerPolicy&&(r.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?r.credentials="include":a.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(a){if(a.ep)return;a.ep=!0;const r=n(a);fetch(a.href,r)}})();const J=`
You are a senior prompt director for Sora 2. Your job is to transform:
- a Base prompt (broad idea),
- a fixed generation length per segment (seconds),
- and a total number of generations (N),

into **N crystal-clear shot prompts** with **maximum continuity** across segments.

Rules:
1) Return **valid JSON** only. Structure:
   {
     "segments": [
       {
         "title": "Generation 1",
         "seconds": 6,
         "prompt": "<prompt block to send into Sora>"
       },
       ...
     ]
   }
   - seconds MUST equal the given generation length for ALL segments.
   - prompt should include a **Context** section for model guidance AND a **Prompt** line for the shot itself.
2) Continuity:
   - Segment 1 starts fresh from the BASE PROMPT.
   - Segment k (k>1) must **begin exactly at the final frame** of segment k-1.
   - Maintain consistent visual style, tone, lighting, and subject identity unless explicitly told to change.
3) Safety & platform constraints:
   - Do not depict real people (including public figures) or copyrighted characters.
   - Avoid copyrighted music and exact trademark/logos.
   - Keep content suitable for general audiences.
4) Output only JSON (no Markdown, no backticks).
5) Keep the **Context** lines inside the prompt text.
6) Make the writing specific and cinematic; describe camera, lighting, motion, and subject focus succinctly.

Example structure for continuity:

Generation 1:
<prompt>
First shot introducing the scene. [Describe opening cinematography, lighting, camera angle, subject, and action.]
</prompt>

Generation 2:
<prompt>
Context (not visible in video, only for AI guidance):
* This is the second part continuing from the previous scene.
* The previous scene ended with [describe final frame].

Prompt: Second shot begins exactly from the final frame of the previous scene. [Describe how the camera moves, what changes in the scene, maintaining visual consistency.]
</prompt>

Generation 3:
<prompt>
Context (not visible in video, only for AI guidance):
* This is the third part continuing from the previous scene.
* The previous scene ended with [describe final frame].

Prompt: Final shot begins exactly from the final frame of the previous scene. [Describe conclusion, camera movement, and any closing elements.]
</prompt>
`.trim();async function X(t,e,n,o){var r;const a=`
BASE PROMPT: ${e}

GENERATION LENGTH (seconds): ${n}
TOTAL GENERATIONS: ${o}

Return exactly ${o} segments with perfect continuity.
`.trim();try{const s=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`},body:JSON.stringify({model:"gpt-4o",messages:[{role:"system",content:J},{role:"user",content:a}],temperature:.7,response_format:{type:"json_object"}})});if(!s.ok){const h=await s.json();throw new Error(((r=h.error)==null?void 0:r.message)||`API request failed: ${s.status}`)}const l=(await s.json()).choices[0].message.content,p=JSON.parse(l).segments||[];return p.length!==o&&(p.length=o),p.forEach(h=>{h.seconds=parseInt(n)}),p}catch(s){throw console.error("Planning error:",s),s}}const T="https://api.openai.com/v1";function Y(t){const e=t.toLowerCase().split(".").pop();return{jpg:"image/jpeg",jpeg:"image/jpeg",png:"image/png",webp:"image/webp"}[e]||"application/octet-stream"}async function Z(t,{prompt:e,size:n,seconds:o,model:a,inputReference:r}){var c;const s=new FormData;s.append("model",a),s.append("prompt",e),s.append("seconds",o.toString()),n&&s.append("size",n),r&&(Y(r.name),s.append("input_reference",r,r.name));try{const l=await fetch(`${T}/videos`,{method:"POST",headers:{Authorization:`Bearer ${t}`},body:s});if(!l.ok){let u=`Failed to create video: ${l.status}`;try{u=((c=(await l.json()).error)==null?void 0:c.message)||u}catch{u=await l.text()||u}throw new Error(u)}return await l.json()}catch(l){throw l.message.includes("Failed to fetch")?new Error("Network error: Cannot connect to OpenAI API. Check your internet connection and API key."):l}}async function Q(t,e){var n;try{const o=await fetch(`${T}/videos/${e}`,{method:"GET",headers:{Authorization:`Bearer ${t}`}});if(!o.ok){let a=`Failed to retrieve video: ${o.status}`;try{a=((n=(await o.json()).error)==null?void 0:n.message)||a}catch{a=await o.text()||a}throw new Error(a)}return await o.json()}catch(o){throw o.message.includes("Failed to fetch")?new Error("Network error: Cannot connect to OpenAI API."):o}}async function ee(t,e,n,o=2e3){var s;let a=e;const r=a.id;for(;a.status==="queued"||a.status==="in_progress";){const c=parseFloat(a.progress||0),l=a.status==="queued"?"Queued":"Processing";n&&n({status:l,progress:c}),await new Promise(u=>setTimeout(u,o)),a=await Q(t,r)}if(a.status!=="completed"){const c=((s=a.error)==null?void 0:s.message)||`Job ${r} failed with status: ${a.status}`;throw new Error(c)}return a}async function te(t,e,n="video"){try{const o=await fetch(`${T}/videos/${e}/content?variant=${n}`,{method:"GET",headers:{Authorization:`Bearer ${t}`}});if(!o.ok)throw new Error(`Failed to download video: ${o.status}`);return await o.blob()}catch(o){throw o.message.includes("Failed to fetch")?new Error("Network error: Cannot download video content."):o}}async function ne(t,e,n){return new Promise((o,a)=>{const r=document.createElement("video"),s=URL.createObjectURL(t);r.preload="metadata",r.muted=!0,r.playsInline=!0,r.onloadedmetadata=()=>{r.currentTime=r.duration-.001},r.onseeked=()=>{try{const c=document.createElement("canvas");c.width=e,c.height=n,c.getContext("2d").drawImage(r,0,0,e,n),c.toBlob(u=>{URL.revokeObjectURL(s),r.remove(),u?o(u):a(new Error("Failed to extract frame as blob"))},"image/jpeg",.95)}catch(c){URL.revokeObjectURL(s),r.remove(),a(c)}},r.onerror=()=>{URL.revokeObjectURL(s),r.remove(),a(new Error("Failed to load video for frame extraction"))},r.src=s})}function oe(t){const[e,n]=t.split("x").map(Number);return{width:e,height:n}}var m;(function(t){t.LOAD="LOAD",t.EXEC="EXEC",t.FFPROBE="FFPROBE",t.WRITE_FILE="WRITE_FILE",t.READ_FILE="READ_FILE",t.DELETE_FILE="DELETE_FILE",t.RENAME="RENAME",t.CREATE_DIR="CREATE_DIR",t.LIST_DIR="LIST_DIR",t.DELETE_DIR="DELETE_DIR",t.ERROR="ERROR",t.DOWNLOAD="DOWNLOAD",t.PROGRESS="PROGRESS",t.LOG="LOG",t.MOUNT="MOUNT",t.UNMOUNT="UNMOUNT"})(m||(m={}));const re=(()=>{let t=0;return()=>t++})(),ae=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),se=new Error("called FFmpeg.terminate()");var E,b,w,R,L,B,f;class ie{constructor(){y(this,E,null);y(this,b,{});y(this,w,{});y(this,R,[]);y(this,L,[]);g(this,"loaded",!1);y(this,B,()=>{d(this,E)&&(d(this,E).onmessage=({data:{id:e,type:n,data:o}})=>{switch(n){case m.LOAD:this.loaded=!0,d(this,b)[e](o);break;case m.MOUNT:case m.UNMOUNT:case m.EXEC:case m.FFPROBE:case m.WRITE_FILE:case m.READ_FILE:case m.DELETE_FILE:case m.RENAME:case m.CREATE_DIR:case m.LIST_DIR:case m.DELETE_DIR:d(this,b)[e](o);break;case m.LOG:d(this,R).forEach(a=>a(o));break;case m.PROGRESS:d(this,L).forEach(a=>a(o));break;case m.ERROR:d(this,w)[e](o);break}delete d(this,b)[e],delete d(this,w)[e]})});y(this,f,({type:e,data:n},o=[],a)=>d(this,E)?new Promise((r,s)=>{const c=re();d(this,E)&&d(this,E).postMessage({id:c,type:e,data:n},o),d(this,b)[c]=r,d(this,w)[c]=s,a==null||a.addEventListener("abort",()=>{s(new DOMException(`Message # ${c} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(ae));g(this,"load",({classWorkerURL:e,...n}={},{signal:o}={})=>(d(this,E)||(O(this,E,e?new Worker(new URL(e,import.meta.url),{type:"module"}):new Worker(new URL("/assets/worker-BAOIWoxA.js",import.meta.url),{type:"module"})),d(this,B).call(this)),d(this,f).call(this,{type:m.LOAD,data:n},void 0,o)));g(this,"exec",(e,n=-1,{signal:o}={})=>d(this,f).call(this,{type:m.EXEC,data:{args:e,timeout:n}},void 0,o));g(this,"ffprobe",(e,n=-1,{signal:o}={})=>d(this,f).call(this,{type:m.FFPROBE,data:{args:e,timeout:n}},void 0,o));g(this,"terminate",()=>{const e=Object.keys(d(this,w));for(const n of e)d(this,w)[n](se),delete d(this,w)[n],delete d(this,b)[n];d(this,E)&&(d(this,E).terminate(),O(this,E,null),this.loaded=!1)});g(this,"writeFile",(e,n,{signal:o}={})=>{const a=[];return n instanceof Uint8Array&&a.push(n.buffer),d(this,f).call(this,{type:m.WRITE_FILE,data:{path:e,data:n}},a,o)});g(this,"mount",(e,n,o)=>{const a=[];return d(this,f).call(this,{type:m.MOUNT,data:{fsType:e,options:n,mountPoint:o}},a)});g(this,"unmount",e=>{const n=[];return d(this,f).call(this,{type:m.UNMOUNT,data:{mountPoint:e}},n)});g(this,"readFile",(e,n="binary",{signal:o}={})=>d(this,f).call(this,{type:m.READ_FILE,data:{path:e,encoding:n}},void 0,o));g(this,"deleteFile",(e,{signal:n}={})=>d(this,f).call(this,{type:m.DELETE_FILE,data:{path:e}},void 0,n));g(this,"rename",(e,n,{signal:o}={})=>d(this,f).call(this,{type:m.RENAME,data:{oldPath:e,newPath:n}},void 0,o));g(this,"createDir",(e,{signal:n}={})=>d(this,f).call(this,{type:m.CREATE_DIR,data:{path:e}},void 0,n));g(this,"listDir",(e,{signal:n}={})=>d(this,f).call(this,{type:m.LIST_DIR,data:{path:e}},void 0,n));g(this,"deleteDir",(e,{signal:n}={})=>d(this,f).call(this,{type:m.DELETE_DIR,data:{path:e}},void 0,n))}on(e,n){e==="log"?d(this,R).push(n):e==="progress"&&d(this,L).push(n)}off(e,n){e==="log"?O(this,R,d(this,R).filter(o=>o!==n)):e==="progress"&&O(this,L,d(this,L).filter(o=>o!==n))}}E=new WeakMap,b=new WeakMap,w=new WeakMap,R=new WeakMap,L=new WeakMap,B=new WeakMap,f=new WeakMap;var j;(function(t){t.MEMFS="MEMFS",t.NODEFS="NODEFS",t.NODERAWFS="NODERAWFS",t.IDBFS="IDBFS",t.WORKERFS="WORKERFS",t.PROXYFS="PROXYFS"})(j||(j={}));const ce=new Error("failed to get response body reader"),de=new Error("failed to complete download"),le="Content-Length",me=t=>new Promise((e,n)=>{const o=new FileReader;o.onload=()=>{const{result:a}=o;a instanceof ArrayBuffer?e(new Uint8Array(a)):e(new Uint8Array)},o.onerror=a=>{var r,s;n(Error(`File could not be read! Code=${((s=(r=a==null?void 0:a.target)==null?void 0:r.error)==null?void 0:s.code)||-1}`))},o.readAsArrayBuffer(t)}),z=async t=>{let e;if(typeof t=="string")/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(t)?e=atob(t.split(",")[1]).split("").map(n=>n.charCodeAt(0)):e=await(await fetch(t)).arrayBuffer();else if(t instanceof URL)e=await(await fetch(t)).arrayBuffer();else if(t instanceof File||t instanceof Blob)e=await me(t);else return new Uint8Array;return new Uint8Array(e)},ue=async(t,e)=>{var a;const n=await fetch(t);let o;try{const r=parseInt(n.headers.get(le)||"-1"),s=(a=n.body)==null?void 0:a.getReader();if(!s)throw ce;const c=[];let l=0;for(;;){const{done:h,value:I}=await s.read(),v=I?I.length:0;if(h){if(r!=-1&&r!==l)throw de;e&&e({url:t,total:r,received:l,delta:v,done:h});break}c.push(I),l+=v,e&&e({url:t,total:r,received:l,delta:v,done:h})}const u=new Uint8Array(l);let p=0;for(const h of c)u.set(h,p),p+=h.length;o=u.buffer}catch(r){console.log("failed to send download progress event: ",r),o=await n.arrayBuffer()}return o},k=async(t,e,n=!1,o)=>{const a=n?await ue(t,o):await(await fetch(t)).arrayBuffer(),r=new Blob([a],{type:e});return URL.createObjectURL(r)};let D=null,M=!1;async function G(){if(M&&D)return D;try{D=new ie;const t="https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm";return await D.load({coreURL:await k(`${t}/ffmpeg-core.js`,"text/javascript"),wasmURL:await k(`${t}/ffmpeg-core.wasm`,"application/wasm")}),M=!0,D}catch(t){throw console.error("Failed to load FFmpeg:",t),t}}async function pe(t){try{const e=await G();for(let r=0;r<t.length;r++){const s=`input${r}.mp4`;await e.writeFile(s,await z(t[r]))}const n=t.map((r,s)=>`file 'input${s}.mp4'`).join(`
`);await e.writeFile("concat.txt",n),await e.exec(["-f","concat","-safe","0","-i","concat.txt","-c","copy","output.mp4"]);const o=await e.readFile("output.mp4"),a=new Blob([o.buffer],{type:"video/mp4"});for(let r=0;r<t.length;r++)await e.deleteFile(`input${r}.mp4`);return await e.deleteFile("concat.txt"),await e.deleteFile("output.mp4"),a}catch(e){throw console.error("FFmpeg concatenation failed:",e),e}}async function ge(t){try{const e=await G();for(let r=0;r<t.length;r++){const s=`input${r}.mp4`;await e.writeFile(s,await z(t[r]))}const n=t.map((r,s)=>`file 'input${s}.mp4'`).join(`
`);await e.writeFile("concat.txt",n),await e.exec(["-f","concat","-safe","0","-i","concat.txt","-c:v","libx264","-preset","medium","-crf","23","-c:a","aac","-b:a","128k","-ar","48000","-ac","2","output.mp4"]);const o=await e.readFile("output.mp4"),a=new Blob([o.buffer],{type:"video/mp4"});for(let r=0;r<t.length;r++)await e.deleteFile(`input${r}.mp4`);return await e.deleteFile("concat.txt"),await e.deleteFile("output.mp4"),a}catch(e){throw console.error("FFmpeg re-encode concatenation failed:",e),e}}async function fe(t,e){if(!t||t.length===0)throw new Error("No video segments to concatenate");if(t.length===1)return t[0];e&&e({status:"Loading FFmpeg...",progress:0});try{e&&e({status:"Concatenating (copy mode)...",progress:30});const n=await pe(t);return e&&e({status:"Concatenation complete",progress:100}),n}catch(n){console.warn("Copy mode failed, attempting re-encode:",n.message);try{e&&e({status:"Concatenating (re-encode mode)...",progress:50});const o=await ge(t);return e&&e({status:"Concatenation complete",progress:100}),o}catch(o){throw console.error("Both concat methods failed:",o),new Error("Failed to concatenate videos with both methods")}}}const i={apiKey:"",basePrompt:"",model:"sora-2",size:"1280x720",secondsPerSegment:8,numSegments:3,plannedSegments:null,generatedSegments:[],finalVideo:null,isGenerating:!1},K={"sora-2":["1280x720","720x1280"],"sora-2-pro":["1280x720","720x1280","1024x1792","1792x1024"]};function he(){const t=document.getElementById("apiKey"),e=document.getElementById("basePrompt"),n=document.getElementById("model"),o=document.getElementById("size"),a=document.getElementById("secondsPerSegment"),r=document.getElementById("numSegments"),s=document.getElementById("planBtn"),c=document.getElementById("generateBtn");t.addEventListener("input",l=>{i.apiKey=l.target.value.trim()}),e.addEventListener("input",l=>{i.basePrompt=l.target.value.trim()}),n.addEventListener("change",l=>{i.model=l.target.value,Ee()}),o.addEventListener("change",l=>{i.size=l.target.value}),a.addEventListener("change",l=>{i.secondsPerSegment=parseInt(l.target.value),P()}),r.addEventListener("input",l=>{i.numSegments=parseInt(l.target.value)||2,P()}),s.addEventListener("click",we),c.addEventListener("click",be),i.basePrompt=e.value.trim(),i.secondsPerSegment=parseInt(a.value),i.numSegments=parseInt(r.value),P()}function Ee(){const t=document.getElementById("size"),e=K[i.model];Array.from(t.options).forEach(n=>{n.value!==""&&(n.disabled=!e.includes(n.value))}),e.includes(i.size)||(i.size=e[0],t.value=i.size)}function P(){const t=i.secondsPerSegment*i.numSegments;document.getElementById("totalDuration").textContent=`Total: ${t} seconds`}function N(t){const e=document.getElementById("errorDisplay");e.textContent=t,e.classList.remove("hidden"),setTimeout(()=>{e.classList.add("hidden")},1e4)}function W(){if(!i.apiKey)throw new Error("Please enter your OpenAI API Key");if(!i.basePrompt)throw new Error("Please enter a base prompt");if(![4,8,12].includes(i.secondsPerSegment))throw new Error("Seconds per segment must be 4, 8, or 12");if(i.numSegments<2||i.numSegments>20)throw new Error("Number of segments must be between 2 and 20");if(!K[i.model].includes(i.size))throw new Error(`Size ${i.size} is not allowed for model ${i.model}`)}async function we(){try{W();const t=document.getElementById("planBtn");t.disabled=!0,t.innerHTML='<span class="btn-icon">⏳</span> Planning...',i.plannedSegments=await X(i.apiKey,i.basePrompt,i.secondsPerSegment,i.numSegments),ye(),document.getElementById("generateBtn").disabled=!1,t.disabled=!1,t.innerHTML='<span class="btn-icon">🎬</span> Plan Segments'}catch(t){console.error("Planning error:",t),N(`Planning failed: ${t.message}`);const e=document.getElementById("planBtn");e.disabled=!1,e.innerHTML='<span class="btn-icon">🎬</span> Plan Segments'}}function ye(){const t=document.getElementById("planOutput"),e=document.getElementById("planSegments");e.innerHTML="",i.plannedSegments.forEach((n,o)=>{const a=document.createElement("div");a.className="plan-segment";const r=document.createElement("h4");r.textContent=`${o+1}. ${n.title||`Segment ${o+1}`} (${n.seconds}s)`;const s=document.createElement("pre");s.textContent=n.prompt,a.appendChild(r),a.appendChild(s),e.appendChild(a)}),t.classList.remove("hidden")}async function be(){if(!i.plannedSegments||i.plannedSegments.length===0){N("Please plan segments first");return}if(i.isGenerating)return;i.isGenerating=!0,i.generatedSegments=[];const t=document.getElementById("generateBtn");t.disabled=!0;const e=document.getElementById("progressContainer"),n=document.getElementById("segmentStatus");e.classList.remove("hidden"),n.classList.remove("hidden"),n.innerHTML="";try{W();const{width:o,height:a}=oe(i.size);let r=null;for(let c=0;c<i.plannedSegments.length;c++){const l=i.plannedSegments[c],u=document.createElement("div");u.className="segment-status-item",u.innerHTML=`
        <div class="segment-status-header">
          <strong>Segment ${c+1} / ${i.plannedSegments.length}</strong>
          <span class="segment-status-label">Initializing...</span>
        </div>
        <div class="segment-progress-bar">
          <div class="segment-progress-fill" style="width: 0%"></div>
        </div>
        <div class="segment-actions hidden">
          <button class="btn-download-segment btn btn-secondary btn-sm" data-index="${c}">
            <span class="btn-icon">⬇</span>
            Download Segment ${c+1}
          </button>
        </div>
      `,n.appendChild(u);const p=u.querySelector(".segment-status-label"),h=u.querySelector(".segment-progress-fill"),I=u.querySelector(".segment-actions"),v=u.querySelector(".btn-download-segment");x(c/i.plannedSegments.length*100,`Generating segment ${c+1}/${i.plannedSegments.length}`);let $=null;r&&($=new File([r],"reference.jpg",{type:"image/jpeg"}));const q=await Z(i.apiKey,{prompt:l.prompt,size:i.size,seconds:l.seconds,model:i.model,inputReference:$});p.textContent="Created job...";const F=await ee(i.apiKey,q,({status:A,progress:S})=>{p.textContent=`${A} ${S.toFixed(1)}%`,h.style.width=`${S}%`});p.textContent="Downloading...";const C=await te(i.apiKey,F.id);i.generatedSegments.push({blob:C,id:F.id,index:c}),p.textContent="Complete",h.style.width="100%",u.classList.add("complete"),I.classList.remove("hidden"),v.onclick=()=>{const A=URL.createObjectURL(C),S=document.createElement("a");S.href=A,S.download=`segment_${c+1}.mp4`,S.click(),URL.revokeObjectURL(A)},p.textContent="Extracting last frame...",c<i.plannedSegments.length-1&&(r=await ne(C,o,a))}Re(),x(95,"Concatenating segments...");const s=await fe(i.generatedSegments.map(c=>c.blob),({status:c,progress:l})=>{x(95+l*.05,c)});i.finalVideo=s,Le(s),x(100,"Complete!"),setTimeout(()=>{e.classList.add("hidden")},2e3)}catch(o){console.error("Generation error:",o),N(`Generation failed: ${o.message}`)}finally{i.isGenerating=!1,t.disabled=!1}}function x(t,e){const n=document.getElementById("progressText"),o=document.getElementById("progressPercent"),a=document.getElementById("progressFill");n.textContent=e,o.textContent=`${Math.round(t)}%`,a.style.width=`${t}%`}function Re(){const t=document.getElementById("segmentPreview"),e=document.getElementById("segmentGallery");e.innerHTML="",i.generatedSegments.forEach((n,o)=>{const a=document.createElement("div");a.className="segment-item";const r=document.createElement("video");r.controls=!0,r.src=URL.createObjectURL(n.blob);const s=document.createElement("div");s.className="segment-label",s.textContent=`Segment ${o+1}`,a.appendChild(r),a.appendChild(s),e.appendChild(a)}),t.classList.remove("hidden")}function Le(t){const e=document.getElementById("finalPreview"),n=document.getElementById("finalVideo"),o=document.getElementById("downloadBtn");n.src=URL.createObjectURL(t),o.onclick=()=>{const a=URL.createObjectURL(t),r=document.createElement("a");r.href=a,r.download="sora-chained-video.mp4",r.click(),URL.revokeObjectURL(a)},e.classList.remove("hidden")}document.addEventListener("DOMContentLoaded",he);
